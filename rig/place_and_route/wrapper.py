'High-level wrapper around place and route functions.\n'
from ..machine import Cores,SDRAM
from .constraints import ReserveResourceConstraint,AlignResourceConstraint
from .util import build_application_map,build_routing_tables
from . import place as default_place
from . import allocate as default_allocate
from . import route as default_route
def wrapper(vertices_resources,vertices_applications,nets,net_keys,machine,constraints=[],reserve_monitor=True,align_sdram=True,place=default_place,place_kwargs={},allocate=default_allocate,allocate_kwargs={},route=default_route,route_kwargs={},core_resource=Cores,sdram_resource=SDRAM):
 'Wrapper for core place-and-route tasks for the common case.\n\n    At a high level this function essentially takes a set of vertices and nets\n    and produces placements, memory allocations, routing tables and application\n    loading information.\n\n    Parameters\n    ----------\n    vertices_resources : {vertex: {resource: quantity, ...}, ...}\n        A dictionary from vertex to the required resources for that vertex.\n        This dictionary must include an entry for every vertex in the\n        application.\n\n        Resource requirements are specified by a dictionary `{resource:\n        quantity, ...}` where `resource` is some resource identifier and\n        `quantity` is a non-negative integer representing the quantity of that\n        resource required.\n    vertices_applications : {vertex: application, ...}\n        A dictionary from vertices to the application binary to load\n        onto cores associated with that vertex. Applications are given as a\n        string containing the file name of the binary to load.\n    nets : [:py:class:`~rig.netlist.Net`, ...]\n        A list (in no particular order) defining the nets connecting vertices.\n    net_keys : {:py:class:`~rig.netlist.Net`: (key, mask), ...}\n        A dictionary from nets to (key, mask) tuples to be used in SpiNNaker\n        routing tables for routes implementing this net. The key and mask\n        should be given as 32-bit integers.\n    machine : :py:class:`rig.machine.Machine`\n        A data structure which defines the resources available in the target\n        SpiNNaker machine.\n    constraints : [constraint, ...]\n        A list of constraints on placement, allocation and routing. Available\n        constraints are provided in the\n        :py:mod:`rig.place_and_route.constraints` module.\n    reserve_monitor : bool (Default: True)\n        **Optional.** If True, reserve core zero since it will be used as the\n        monitor processor using a\n        :py:class:`rig.place_and_route.constraints.ReserveResourceConstraint`.\n    align_sdram : bool (Default: True)\n        **Optional.** If True, SDRAM allocations will be aligned to 4-byte\n        addresses.  Specifically, the supplied constraints will be augmented\n        with an `AlignResourceConstraint(sdram_resource, 4)`.\n    place : function (Default: :py:func:`rig.place_and_route.place`)\n        **Optional.** Placement algorithm to use.\n    place_kwargs : dict (Default: {})\n        **Optional.** Algorithm-specific arguments for the placer.\n    allocate : function (Default: :py:func:`rig.place_and_route.allocate`)\n        **Optional.** Allocation algorithm to use.\n    allocate_kwargs : dict (Default: {})\n        **Optional.** Algorithm-specific arguments for the allocator.\n    route : function (Default: :py:func:`rig.place_and_route.route`)\n        **Optional.** Routing algorithm to use.\n    route_kwargs : dict (Default: {})\n        **Optional.** Algorithm-specific arguments for the router.\n    core_resource : resource (Default: :py:data:`~rig.machine.Cores`)\n        **Optional.** The resource identifier used for cores.\n    sdram_resource : resource (Default: :py:data:`~rig.machine.SDRAM`)\n        **Optional.** The resource identifier used for SDRAM.\n\n    Returns\n    -------\n    placements : {vertex: (x, y), ...}\n        A dictionary from vertices to the chip coordinate produced by\n        placement.\n    allocations : {vertex: {resource: slice, ...}, ...}\n        A dictionary from vertices to the resources allocated to it. Resource\n        allocations are dictionaries from resources to a :py:class:`slice`\n        defining the range of the given resource type allocated to the vertex.\n        These :py:class:`slice` objects have `start` <= `end` and `step` set to\n        None.\n    application_map : {application: {(x, y): set([core_num, ...]), ...}, ...}\n        A dictionary from application to the set of cores it should be loaded\n        onto. The set of cores is given as a dictionary from chip to sets of\n        core numbers.\n    routing_tables : {(x, y):                       [:py:class:`~rig.routing_table.RoutingTableEntry`,                        ...], ...}\n        The generated routing tables. Provided as a dictionary from chip to a\n        list of routing table entries.\n    ';constraints=constraints[:]
 if reserve_monitor:constraints.append(ReserveResourceConstraint(core_resource,slice(0,1)))
 if align_sdram:constraints.append(AlignResourceConstraint(sdram_resource,4))
 placements=place(vertices_resources,nets,machine,constraints,**place_kwargs);allocations=allocate(vertices_resources,nets,machine,constraints,placements,**allocate_kwargs);routes=route(vertices_resources,nets,machine,constraints,placements,allocations,core_resource,**route_kwargs);application_map=build_application_map(vertices_applications,placements,allocations,core_resource);routing_tables=build_routing_tables(routes,net_keys);return placements,allocations,application_map,routing_tables
