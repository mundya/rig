from six import iteritems
import time
import struct
import collections
from .scp_connection import SCPConnection
from . import consts
from .consts import SCPCommands,LEDAction,BMPInfoType,BMP_V_SCALE_2_5,BMP_V_SCALE_3_3,BMP_V_SCALE_12,BMP_TEMP_SCALE,BMP_MISSING_TEMP,BMP_MISSING_FAN
from rig.utils.contexts import ContextMixin,Required
class BMPController(ContextMixin):
 "Control the BMPs (Board Management Processors) onboard SpiNN-5 boards in\n    a SpiNNaker machine.\n\n    BMPs (and thus boards) are addressed as follows::\n\n                  2             1                0\n        Cabinet --+-------------+----------------+\n                  |             |                |\n        +-------------+  +-------------+  +-------------+    Frame\n        |             |  |             |  |             |      |\n        | +---------+ |  | +---------+ |  | +---------+ |      |\n        | | : : : : | |  | | : : : : | |  | | : : : : |--------+ 0\n        | | : : : : | |  | | : : : : | |  | | : : : : | |      |\n        | +---------+ |  | +---------+ |  | +---------+ |      |\n        | | : : : : | |  | | : : : : | |  | | : : : : |--------+ 1\n        | | : : : : | |  | | : : : : | |  | | : : : : | |      |\n        | +---------+ |  | +---------+ |  | +---------+ |      |\n        | | : : : : | |  | | : : : : | |  | | : : : : |--------+ 2\n        | | : : : : | |  | | : : : : | |  | | : : : : | |      |\n        | +---------+ |  | +---------+ |  | +---------+ |      |\n        | | : : : : | |  | | : : : : | |  | | : : : : |--------+ 3\n        | | : : : : | |  | | : : : : | |  | | : : : : | |\n        | +---------+ |  | +|-|-|-|-|+ |  | +---------+ |\n        |             |  |  | | | | |  |  |             |\n        +-------------+  +--|-|-|-|-|--+  +-------------+\n                            | | | | |\n                 Board -----+-+-+-+-+\n                            4 3 2 1 0\n\n    Coordinates are conventionally written as 3-tuples of integers (cabinet,\n    frame, board). This gives the upper-right-most board's coordinate (0, 0,\n    0).\n\n    Communication with BMPs is facilitated either directly via Ethernet or\n    indirectly via the Ethernet connection of another BMP and the CAN bus in\n    the backplane of each frame.\n\n    This class aims not to be a complete BMP communication solution (users are\n    referred instead to the general-purpose `bmpc` utility), but rather to\n    cover common uses of the BMP in normal application usage.\n    "
 def __init__(self,hosts,scp_port=consts.SCP_PORT,n_tries=5,timeout=.5,initial_context={'cabinet':0,'frame':0,'board':0}):
  'Create a new controller for BMPs in a SpiNNaker machine.\n\n        Parameters\n        ----------\n        hosts : string or {coord: string, ...}\n            Hostname or IP address of the BMP to connect to or alternatively,\n            multiple addresses can be given in a dictionary to allow control of\n            many boards. `coord` may be given as ether (cabinet, frame) or\n            (cabinet, frame, board) tuples. In the former case, the address\n            will be used to communicate with all boards in the specified frame\n            except those listed explicitly. If only a single hostname is\n            supplied it is assumed to be for all boards in cabinet 0, frame 0.\n        scp_port : int\n            Port number to use for all SCP connections\n        n_tries : int\n            Number of SDP packet retransmission attempts.\n        timeout : float\n            SDP response timeout.\n        initial_context : `{argument: value}`\n            Dictionary of default arguments to pass to methods in this class.\n            This defaults to selecting the coordinate (0, 0, 0) which is\n            convenient in single-board systems.\n        ';ContextMixin.__init__(self,initial_context);self.scp_port=scp_port;self.n_tries=n_tries;self.timeout=timeout;self._scp_data_length=None
  if isinstance(hosts,str):hosts={(0,0):hosts}
  self.connections={coord:SCPConnection(host,scp_port,n_tries,timeout) for (coord,host) in iteritems(hosts)}
 @property
 def scp_data_length(self):
  if self._scp_data_length is None:
   coord=max(self.connections,key=len)
   if len(coord)==2:coord=coord[0],coord[1],0
   data=self.get_software_version(*coord);self._scp_data_length=data.buffer_size
  return self._scp_data_length
 def __call__(self,**context_args):'Create a new context for use with `with`.';return self.get_new_context(**context_args)
 @ContextMixin.use_named_contextual_arguments(cabinet=Required,frame=Required,board=Required)
 def send_scp(self,*args,**kwargs):'Transmit an SCP Packet to a specific board.\n\n        Automatically determines the appropriate connection to use.\n\n        See the arguments for\n        :py:meth:`~rig.machine_control.scp_connection.SCPConnection` for\n        details.\n\n        Parameters\n        ----------\n        cabinet : int\n        frame : int\n        board : int\n        ';cabinet=kwargs.pop('cabinet');frame=kwargs.pop('frame');board=kwargs.pop('board');return self._send_scp(cabinet,frame,board,*args,**kwargs)
 def _send_scp(self,cabinet,frame,board,*args,**kwargs):
  'Determine the best connection to use to send an SCP packet and use\n        it to transmit.\n\n        See the arguments for\n        :py:meth:`~rig.machine_control.scp_connection.SCPConnection` for\n        details.\n        ';connection=self.connections.get((cabinet,frame,board),None)
  if connection is None:connection=self.connections.get((cabinet,frame),None)
  assert connection is not None,'No connection available to ({}, {}, {})'.format(cabinet,frame,board)
  if self._scp_data_length is None:length=consts.SCP_SVER_RECEIVE_LENGTH_MAX
  else:length=self._scp_data_length
  return connection.send_scp(length,0,0,board,*args,**kwargs)
 @ContextMixin.use_contextual_arguments
 def get_software_version(self,cabinet=Required,frame=Required,board=Required):'Get the software version for a given BMP.\n\n        Returns\n        -------\n        :py:class:`.BMPInfo`\n            Information about the software running on a BMP.\n        ';sver=self._send_scp(cabinet,frame,board,SCPCommands.sver);code_block=sver.arg1>>24&255;frame_id=sver.arg1>>16&255;can_id=sver.arg1>>8&255;board_id=sver.arg1&255;version=(sver.arg2>>16)/1e2;buffer_size=sver.arg2&65535;return BMPInfo(code_block,frame_id,can_id,board_id,version,buffer_size,sver.arg3,sver.data.decode('utf-8'))
 @ContextMixin.use_contextual_arguments
 def set_power(self,state,cabinet=Required,frame=Required,board=Required,delay=0.,post_power_on_delay=5.):
  'Control power to the SpiNNaker chips and FPGAs on a board.\n\n        Returns\n        -------\n        state : bool\n            True for power on, False for power off.\n        board : int or iterable\n            Specifies the board to control the power of. This may also be an\n            iterable of multiple boards (in the same frame). The command will\n            actually be sent to the first board in the iterable.\n        delay : float\n            Number of seconds delay between power state changes of different\n            boards.\n        post_power_on_delay : float\n            Number of seconds for this command to block once the power on\n            command has been carried out. A short delay (default) is useful at\n            this point since power-supplies and SpiNNaker chips may still be\n            coming on line immediately after the power-on command is sent.\n        '
  if isinstance(board,int):boards=[board]
  else:boards=list(board);board=boards[0]
  arg1=int(delay*1000)<<16|(1 if state else 0);arg2=sum(1<<b for b in boards);self._send_scp(cabinet,frame,board,SCPCommands.power,arg1=arg1,arg2=arg2,timeout=consts.BMP_POWER_ON_TIMEOUT if state else 0.,expected_args=0)
  if state:time.sleep(post_power_on_delay)
 @ContextMixin.use_contextual_arguments
 def set_led(self,led,action=None,cabinet=Required,frame=Required,board=Required):
  'Set or toggle the state of an LED.\n\n        .. note::\n            At the time of writing, LED 7 is only set by the BMP on start-up to\n            indicate that the watchdog timer reset the board. After this point,\n            the LED is available for use by applications.\n\n        Parameters\n        ----------\n        led : int or iterable\n            Number of the LED or an iterable of LEDs to set the state of (0-7)\n        action : bool or None\n            State to set the LED to. True for on, False for off, None to\n            toggle (default).\n        board : int or iterable\n            Specifies the board to control the LEDs of. This may also be an\n            iterable of multiple boards (in the same frame). The command will\n            actually be sent to the first board in the iterable.\n        '
  if isinstance(led,int):leds=[led]
  else:leds=led
  if isinstance(board,int):boards=[board]
  else:boards=list(board);board=boards[0]
  arg1=sum(LEDAction.from_bool(action)<<led*2 for led in leds);arg2=sum(1<<b for b in boards);self._send_scp(cabinet,frame,board,SCPCommands.led,arg1=arg1,arg2=arg2,expected_args=0)
 @ContextMixin.use_contextual_arguments
 def read_fpga_reg(self,fpga_num,addr,cabinet=Required,frame=Required,board=Required):"Read the value of an FPGA (SPI) register.\n\n        See the SpI/O project's spinnaker_fpga design's `README`_ for a listing\n        of FPGA registers. The SpI/O project can be found on GitHub at:\n        https://github.com/SpiNNakerManchester/spio/\n\n        .. _README: https://github.com/SpiNNakerManchester/spio/                    blob/master/designs/spinnaker_fpgas/README.md#spi-interface\n\n        Parameters\n        ----------\n        fpga_num : int\n            FPGA number (0, 1 or 2) to communicate with.\n        addr : int\n            Register address to read to (will be rounded down to the nearest\n            32-bit word boundary).\n\n        Returns\n        -------\n        int\n            The 32-bit value at that address.\n        ";arg1=addr&~3;arg2=4;arg3=fpga_num;response=self._send_scp(cabinet,frame,board,SCPCommands.link_read,arg1=arg1,arg2=arg2,arg3=arg3,expected_args=0);return struct.unpack('<I',response.data)[0]
 @ContextMixin.use_contextual_arguments
 def write_fpga_reg(self,fpga_num,addr,value,cabinet=Required,frame=Required,board=Required):"Write the value of an FPGA (SPI) register.\n\n        See the SpI/O project's spinnaker_fpga design's `README`_ for a listing\n        of FPGA registers. The SpI/O project can be found on GitHub at:\n        https://github.com/SpiNNakerManchester/spio/\n\n        .. _README: https://github.com/SpiNNakerManchester/spio/                    blob/master/designs/spinnaker_fpgas/README.md#spi-interface\n\n        Parameters\n        ----------\n        fpga_num : int\n            FPGA number (0, 1 or 2) to communicate with.\n        addr : int\n            Register address to read or write to (will be rounded down to the\n            nearest 32-bit word boundary).\n        value : int\n            A 32-bit int value to write to the register\n        ";arg1=addr&~3;arg2=4;arg3=fpga_num;self._send_scp(cabinet,frame,board,SCPCommands.link_write,arg1=arg1,arg2=arg2,arg3=arg3,data=struct.pack('<I',value),expected_args=0)
 @ContextMixin.use_contextual_arguments
 def read_adc(self,cabinet=Required,frame=Required,board=Required):'Read ADC data from the BMP including voltages and temperature.\n\n        Returns\n        -------\n        :py:class:`.ADCInfo`\n        ';response=self._send_scp(cabinet,frame,board,SCPCommands.bmp_info,arg1=BMPInfoType.adc,expected_args=0);data=struct.unpack('<8H4h4h4hII',response.data);return ADCInfo(voltage_1_2c=data[1]*BMP_V_SCALE_2_5,voltage_1_2b=data[2]*BMP_V_SCALE_2_5,voltage_1_2a=data[3]*BMP_V_SCALE_2_5,voltage_1_8=data[4]*BMP_V_SCALE_2_5,voltage_3_3=data[6]*BMP_V_SCALE_3_3,voltage_supply=data[7]*BMP_V_SCALE_12,temp_top=float(data[8])*BMP_TEMP_SCALE,temp_btm=float(data[9])*BMP_TEMP_SCALE,temp_ext_0=float(data[12])*BMP_TEMP_SCALE if data[12]!=BMP_MISSING_TEMP else None,temp_ext_1=float(data[13])*BMP_TEMP_SCALE if data[13]!=BMP_MISSING_TEMP else None,fan_0=float(data[16]) if data[16]!=BMP_MISSING_FAN else None,fan_1=float(data[17]) if data[17]!=BMP_MISSING_FAN else None)
class BMPInfo(collections.namedtuple('BMPInfo','code_block frame_id can_id board_id version buffer_size build_date version_string')):'Information returned about a BMP by sver.\n\n    Parameters\n    ----------\n    code_block : int\n        The BMP, on power-up, will execute the first valid block in its flash\n        storage. This value which indicates which 64 KB block was selected.\n    frame_id : int\n        An identifier programmed into the EEPROM of the backplane which\n        uniquely identifies the frame the board is in. Note: This ID is not\n        necessarily the same as a board\'s frame-coordinate.\n    can_id : int\n        ID of the board in the backplane CAN bus.\n    board_id : int\n        The position of the board in a frame. (This should correspond exactly\n        with a board\'s board-coordinate.\n    version : float\n        Software version number. (Major version is integral part, minor version\n        is fractional part).\n    buffer_size : int\n        Maximum supported size (in bytes) of the data portion of an SCP packet.\n    build_date : int\n        The time at which the software was compiled as a unix timestamp. May be\n        zero if not set.\n    version_string : string\n        Human readable, textual version information split in to two fields by a\n        "/". In the first field is the kernel (e.g. BC&MP) and the second the\n        hardware platform (e.g. Spin5-BMP).\n    '
class ADCInfo(collections.namedtuple('ADCInfo','voltage_1_2c voltage_1_2b voltage_1_2a voltage_1_8 voltage_3_3 voltage_supply temp_top temp_btm temp_ext_0 temp_ext_1 fan_0 fan_1')):'ADC data returned by a BMP including voltages and temperature.\n\n    Parameters\n    ----------\n    voltage_1_2a : float\n        Measured voltage on the 1.2 V rail A.\n    voltage_1_2b : float\n        Measured voltage on the 1.2 V rail B.\n    voltage_1_2c : float\n        Measured voltage on the 1.2 V rail C.\n    voltage_1_8 : float\n        Measured voltage on the 1.8 V rail.\n    voltage_3_3 : float\n        Measured voltage on the 3.3 V rail.\n    voltage_supply : float\n        Measured voltage of the (12 V) power supply input.\n    temp_top : float\n        Temperature near the top of the board (degrees Celsius)\n    temp_btm : float\n        Temperature near the bottom of the board (degrees Celsius)\n    temp_ext_0 : float\n        Temperature read from external sensor 0 (degrees Celsius) or None if\n        not connected.\n    temp_ext_1 : float\n        Temperature read from external sensor 1 (degrees Celsius) or None if\n        not connected.\n    fan_0 : int\n        External fan speed (RPM) of fan 0 or None if not connected.\n    fan_1 : int\n        External fan speed (RPM) of fan 1 or None if not connected.\n    '
